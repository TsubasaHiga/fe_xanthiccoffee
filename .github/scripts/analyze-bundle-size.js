import { execSync } from 'node:child_process'
import fs from 'node:fs'
import path from 'node:path'
import { fileURLToPath } from 'node:url'
import zlib from 'node:zlib'

const CONFIG = {
  TOP_FILES_LIMIT: 5,
  DECIMAL_PLACES: 2,
  COMMIT_HASH_LENGTH: 7,
  SUPPORTED_EXTENSIONS: ['.js', '.css']
}

const formatBytesToKB = (bytes) => (bytes / 1024).toFixed(CONFIG.DECIMAL_PLACES)
const isSupportedFile = (filename) =>
  CONFIG.SUPPORTED_EXTENSIONS.some((ext) => filename.endsWith(ext))
const getFileType = (filename) => (filename.endsWith('.js') ? 'JS' : 'CSS')

function getFileSizeData(filePath) {
  try {
    const stats = fs.statSync(filePath)
    const gzipped = zlib.gzipSync(fs.readFileSync(filePath))
    return {
      size: Number.parseFloat(formatBytesToKB(stats.size)),
      gzipSize: Number.parseFloat(formatBytesToKB(gzipped.length))
    }
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error.message)
    return { size: 0, gzipSize: 0 }
  }
}

function calculateBundleSize(distPath) {
  const assetsDir = path.join(distPath, 'assets')
  if (!fs.existsSync(assetsDir)) {
    console.warn(`Assets directory not found: ${assetsDir}`)
    return { totalSize: 0, totalGzipSize: 0, files: [] }
  }

  let totalSize = 0
  let totalGzipSize = 0
  const files = []

  for (const file of fs.readdirSync(assetsDir)) {
    if (!isSupportedFile(file)) continue

    const filePath = path.join(assetsDir, file)
    const { size, gzipSize } = getFileSizeData(filePath)

    totalSize += size
    totalGzipSize += gzipSize
    files.push({
      file: path.join('assets', file),
      size: `${size.toFixed(CONFIG.DECIMAL_PLACES)} KB`,
      gzipSize: `${gzipSize.toFixed(CONFIG.DECIMAL_PLACES)} KB`,
      sizeNum: size,
      type: getFileType(file)
    })
  }

  return {
    totalSize: totalSize.toFixed(CONFIG.DECIMAL_PLACES),
    totalGzipSize: totalGzipSize.toFixed(CONFIG.DECIMAL_PLACES),
    files: files.sort((a, b) => b.sizeNum - a.sizeNum)
  }
}

function getPackageInfo() {
  const packageJson = JSON.parse(fs.readFileSync('package.json', 'utf8'))
  return { name: packageJson.name, version: packageJson.version }
}

function getPRInfo() {
  return {
    title: process.env.PR_TITLE || 'Unknown PR',
    number: process.env.PR_NUMBER || '0',
    author: process.env.PR_AUTHOR || 'Unknown'
  }
}

function getCommitHash() {
  try {
    return execSync('git rev-parse HEAD')
      .toString()
      .trim()
      .substring(0, CONFIG.COMMIT_HASH_LENGTH)
  } catch {
    return 'unknown'
  }
}

function processIndexHtml(distDir) {
  const indexPath = path.join(distDir, 'index.html')
  if (!fs.existsSync(indexPath)) return null

  const { size, gzipSize } = getFileSizeData(indexPath)
  return {
    file: 'index.html',
    size: `${size.toFixed(CONFIG.DECIMAL_PLACES)} KB`,
    gzipSize: `${gzipSize.toFixed(CONFIG.DECIMAL_PLACES)} KB`
  }
}

function generateMarkdown(
  packageInfo,
  prInfo,
  commitHash,
  indexInfo,
  bundleData
) {
  const lines = [
    `## üìä Bundle Size - v${packageInfo.version}`,
    '',
    `Merged PR #${prInfo.number}: ${prInfo.title}`,
    '',
    '### Main Bundle Summary',
    '',
    '| File | Size | Gzipped |',
    '| ---- | ---- | ------- |'
  ]

  if (indexInfo) {
    lines.push(
      `| ${indexInfo.file} | ${indexInfo.size} | ${indexInfo.gzipSize} |`
    )
  }

  lines.push(
    `| **Total Assets** | **${bundleData.totalSize} KB** | **${bundleData.totalGzipSize} KB** |`
  )

  if (bundleData.files.length > 0) {
    lines.push('', `### Top ${CONFIG.TOP_FILES_LIMIT} Largest Asset Files`, '')
    lines.push(
      '| File | Size | Gzipped | Type |',
      '| ---- | ---- | ------- | ---- |'
    )

    for (const file of bundleData.files.slice(0, CONFIG.TOP_FILES_LIMIT)) {
      lines.push(
        `| ${file.file} | ${file.size} | ${file.gzipSize} | ${file.type} |`
      )
    }
  }

  lines.push(
    '',
    '> This comment was automatically generated by GitHub Actions ü§ñ'
  )
  lines.push(`> PR by @${prInfo.author} | Commit: ${commitHash}`)

  return lines.join('\n')
}

function analyzeBundleSize() {
  console.log('=== Bundle Size Analysis Started ===')

  const distDir = path.join(process.cwd(), 'dist')
  if (!fs.existsSync(distDir)) {
    console.error(
      'Error: dist directory does not exist. Make sure the build was successful.'
    )
    process.exit(1)
  }

  console.log('‚úÖ Dist directory found')

  const packageInfo = getPackageInfo()
  console.log(`üì¶ Package: ${packageInfo.name} v${packageInfo.version}`)

  console.log('üìä Calculating bundle sizes...')
  const bundleData = calculateBundleSize(distDir)
  console.log(`Found ${bundleData.files.length} asset files`)
  console.log(
    `Total size: ${bundleData.totalSize} KB (${bundleData.totalGzipSize} KB gzipped)`
  )

  const indexInfo = processIndexHtml(distDir)
  const prInfo = getPRInfo()
  const commitHash = getCommitHash()

  const markdown = generateMarkdown(
    packageInfo,
    prInfo,
    commitHash,
    indexInfo,
    bundleData
  )

  const __dirname = path.dirname(fileURLToPath(import.meta.url))
  const tmpDir = path.join(__dirname, '../tmp')

  if (!fs.existsSync(tmpDir)) {
    fs.mkdirSync(tmpDir, { recursive: true })
  }

  const outputPath = path.join(tmpDir, 'bundle-size-comment.md')
  console.log(`üìù Writing comment to: ${outputPath}`)
  fs.writeFileSync(outputPath, markdown)
  console.log(
    `‚úÖ Comment written successfully. File size: ${fs.statSync(outputPath).size} bytes`
  )

  console.log('\nüéâ Bundle size analysis completed successfully!')
  console.log(
    `üìä Final summary: ${bundleData.totalSize} KB (${bundleData.totalGzipSize} KB gzipped)`
  )
}

analyzeBundleSize()
